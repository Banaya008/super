# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `puma` gem.
# Please instead update this file by running `bin/tapioca gem puma`.

class OpenSSL::SSL::SSLServer
  include ::OpenSSL::SSL::SocketForwarder

  def accept_nonblock; end
end

module Puma
  class << self
    # @return [Boolean]
    def jruby?; end

    # Thread name is new in Ruby 2.3
    def set_thread_name(name); end

    def stats; end
    def stats_object=(val); end

    # @return [Boolean]
    def windows?; end
  end
end

class Puma::Binder
  include ::Puma::Const

  # @return [Binder] a new instance of Binder
  def initialize(events); end

  def add_ssl_listener(host, port, ctx, optimize_for_latency = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # Tell the server to listen on host +host+, port +port+.
  # If +optimize_for_latency+ is true (the default) then clients connecting
  # will be optimized for latency over throughput.
  #
  # +backlog+ indicates how many unaccepted connections the kernel should
  # allow to accumulate before returning connection refused.
  def add_tcp_listener(host, port, optimize_for_latency = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # Tell the server to listen on +path+ as a UNIX domain socket.
  def add_unix_listener(path, umask = T.unsafe(nil), mode = T.unsafe(nil), backlog = T.unsafe(nil)); end

  def close; end
  def close_listeners; end
  def close_unix_paths; end

  # Returns the value of attribute connected_port.
  def connected_port; end

  def env(sock); end
  def import_from_env; end
  def inherit_ssl_listener(fd, ctx); end
  def inherit_tcp_listener(host, port, fd); end
  def inherit_unix_listener(path, fd); end

  # Returns the value of attribute ios.
  def ios; end

  def loopback_addresses; end
  def parse(binds, logger); end
  def redirects_for_restart; end
end

Puma::Binder::RACK_VERSION = T.let(T.unsafe(nil), Array)

# An instance of this class represents a unique request from a client.
# For example, this could be a web request from a browser or from CURL.
#
# An instance of `Puma::Client` can be used as if it were an IO object
# by the reactor. The reactor is expected to call `#to_io`
# on any non-IO objects it polls. For example, nio4r internally calls
# `IO::try_convert` (which may call `#to_io`) when a new socket is
# registered.
#
# Instances of this class are responsible for knowing if
# the header and body are fully buffered via the `try_to_finish` method.
# They can be used to "time out" a response via the `timeout_at` reader.
class Puma::Client
  include ::Puma::Const
  extend ::Forwardable

  # @return [Client] a new instance of Client
  def initialize(io, env = T.unsafe(nil)); end

  # Returns the value of attribute body.
  def body; end

  # For the hijack protocol (allows us to just put the Client object
  # into the env)
  def call; end

  def close; end
  def closed?(*args, &block); end
  def eagerly_finish; end

  # Returns the value of attribute env.
  def env; end

  # IS_JRUBY
  def finish; end

  # Returns the value of attribute hijacked.
  def hijacked; end

  def in_data_phase; end
  def inspect; end

  # Returns the value of attribute io.
  def io; end

  def peerip; end

  # Sets the attribute peerip
  #
  # @param value the value to set the attribute peerip to.
  def peerip=(_arg0); end

  # Returns the value of attribute ready.
  def ready; end

  # Returns the value of attribute remote_addr_header.
  def remote_addr_header; end

  # Sets the attribute remote_addr_header
  #
  # @param value the value to set the attribute remote_addr_header to.
  def remote_addr_header=(_arg0); end

  def reset(fast_check = T.unsafe(nil)); end
  def set_timeout(val); end

  # Returns the value of attribute tempfile.
  def tempfile; end

  # Returns the value of attribute timeout_at.
  def timeout_at; end

  # Returns the value of attribute to_io.
  def to_io; end

  def try_to_finish; end
  def write_error(status_code); end

  private

  def decode_chunk(chunk); end
  def read_body; end
  def read_chunked_body; end
  def set_ready; end
  def setup_body; end
  def setup_chunked_body(body); end
  def write_chunk(str); end
end

# this tests all values but the last, which must be chunked
Puma::Client::ALLOWED_TRANSFER_ENCODING = T.let(T.unsafe(nil), Array)

# chunked body validation
Puma::Client::CHUNK_SIZE_INVALID = T.let(T.unsafe(nil), Regexp)

Puma::Client::CHUNK_VALID_ENDING = T.let(T.unsafe(nil), String)

# Content-Length header value validation
Puma::Client::CONTENT_LENGTH_VALUE_INVALID = T.let(T.unsafe(nil), Regexp)

# The object used for a request with no body. All requests with
# no body share this one object since it has no state.
Puma::Client::EmptyBody = T.let(T.unsafe(nil), Puma::NullIO)

Puma::Client::TE_ERR_MSG = T.let(T.unsafe(nil), String)

# This class is instantiated by the `Puma::Launcher` and used
# to boot and serve a Ruby application when puma "workers" are needed
# i.e. when using multi-processes. For example `$ puma -w 5`
#
# At the core of this class is running an instance of `Puma::Server` which
# gets created via the `start_server` method from the `Puma::Runner` class
# that this inherits from.
#
# An instance of this class will spawn the number of processes passed in
# via the `spawn_workers` method call. Each worker will have it's own
# instance of a `Puma::Server`.
class Puma::Cluster < ::Puma::Runner
  # @return [Cluster] a new instance of Cluster
  def initialize(cli, events); end

  # @return [Boolean]
  def all_workers_booted?; end

  def check_workers(force = T.unsafe(nil)); end
  def cull_workers; end
  def halt; end
  def next_worker_index; end
  def phased_restart; end

  # @return [Boolean]
  def preload?; end

  def redirect_io; end
  def reload_worker_directory; end
  def restart; end
  def run; end

  # We do this in a separate method to keep the lambda scope
  # of the signals handlers as small as possible.
  def setup_signals; end

  def spawn_workers; end
  def start_phased_restart; end

  # Inside of a child process, this will return all zeroes, as @workers is only populated in
  # the master process.
  def stats; end

  def stop; end
  def stop_blocked; end
  def stop_workers; end
  def wakeup!; end
  def worker(index, master); end

  private

  # loops thru @workers, removing workers that exited, and calling
  # `#term` if needed
  def wait_workers; end
end

class Puma::Cluster::Worker
  # @return [Worker] a new instance of Worker
  def initialize(idx, pid, phase, options); end

  def boot!; end

  # @return [Boolean]
  def booted?; end

  def hup; end

  # Returns the value of attribute index.
  def index; end

  def kill; end

  # Returns the value of attribute last_checkin.
  def last_checkin; end

  # Returns the value of attribute last_status.
  def last_status; end

  # Returns the value of attribute phase.
  def phase; end

  # Returns the value of attribute pid.
  def pid; end

  def ping!(status); end

  # @return [Boolean]
  def ping_timeout?(which); end

  # Returns the value of attribute signal.
  def signal; end

  # Returns the value of attribute started_at.
  def started_at; end

  def term; end

  # @return [Boolean]
  def term?; end
end

class Puma::ConnectionError < ::RuntimeError; end

# Frequently used constants when constructing requests or responses.  Many times
# the constant just refers to a string with the same contents.  Using these constants
# gave about a 3% to 10% performance improvement over using the strings directly.
#
# The constants are frozen because Hash#[]= when called with a String key dups
# the String UNLESS the String is frozen. This saves us therefore 2 object
# allocations when creating the env hash later.
#
# While Puma does try to emulate the CGI/1.2 protocol, it does not use the REMOTE_IDENT,
# REMOTE_USER, or REMOTE_HOST parameters since those are either a security problem or
# too taxing on performance.
module Puma::Const; end

Puma::Const::CGI_VER = T.let(T.unsafe(nil), String)
Puma::Const::CHUNKED = T.let(T.unsafe(nil), String)

# The basic max request size we'll try to read.
Puma::Const::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

Puma::Const::CLOSE = T.let(T.unsafe(nil), String)
Puma::Const::CLOSE_CHUNKED = T.let(T.unsafe(nil), String)
Puma::Const::CODE_NAME = T.let(T.unsafe(nil), String)
Puma::Const::COLON = T.let(T.unsafe(nil), String)
Puma::Const::CONNECTION_CLOSE = T.let(T.unsafe(nil), String)
Puma::Const::CONNECTION_KEEP_ALIVE = T.let(T.unsafe(nil), String)
Puma::Const::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Puma::Const::CONTENT_LENGTH2 = T.let(T.unsafe(nil), String)
Puma::Const::CONTENT_LENGTH_S = T.let(T.unsafe(nil), String)
Puma::Const::CONTINUE = T.let(T.unsafe(nil), String)
Puma::Const::EARLY_HINTS = T.let(T.unsafe(nil), String)
Puma::Const::ERROR_RESPONSE = T.let(T.unsafe(nil), Hash)
Puma::Const::FAST_TRACK_KA_TIMEOUT = T.let(T.unsafe(nil), Float)

# The default number of seconds to wait until we get the first data
# for the request
Puma::Const::FIRST_DATA_TIMEOUT = T.let(T.unsafe(nil), Integer)

Puma::Const::GATEWAY_INTERFACE = T.let(T.unsafe(nil), String)
Puma::Const::HALT_COMMAND = T.let(T.unsafe(nil), String)
Puma::Const::HEAD = T.let(T.unsafe(nil), String)
Puma::Const::HIJACK = T.let(T.unsafe(nil), String)
Puma::Const::HIJACK_IO = T.let(T.unsafe(nil), String)
Puma::Const::HIJACK_P = T.let(T.unsafe(nil), String)
Puma::Const::HTTP = T.let(T.unsafe(nil), String)
Puma::Const::HTTPS = T.let(T.unsafe(nil), String)
Puma::Const::HTTPS_KEY = T.let(T.unsafe(nil), String)
Puma::Const::HTTP_10_200 = T.let(T.unsafe(nil), String)
Puma::Const::HTTP_11 = T.let(T.unsafe(nil), String)
Puma::Const::HTTP_11_100 = T.let(T.unsafe(nil), String)
Puma::Const::HTTP_11_200 = T.let(T.unsafe(nil), String)
Puma::Const::HTTP_CONNECTION = T.let(T.unsafe(nil), String)
Puma::Const::HTTP_EXPECT = T.let(T.unsafe(nil), String)
Puma::Const::HTTP_HOST = T.let(T.unsafe(nil), String)
Puma::Const::HTTP_INJECTION_REGEX = T.let(T.unsafe(nil), Regexp)
Puma::Const::HTTP_VERSION = T.let(T.unsafe(nil), String)
Puma::Const::HTTP_X_FORWARDED_FOR = T.let(T.unsafe(nil), String)
Puma::Const::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)
Puma::Const::HTTP_X_FORWARDED_SCHEME = T.let(T.unsafe(nil), String)
Puma::Const::HTTP_X_FORWARDED_SSL = T.let(T.unsafe(nil), String)
Puma::Const::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# ETag is based on the apache standard of hex mtime-size-inode (inode is 0 on win32)
Puma::Const::LINE_END = T.let(T.unsafe(nil), String)

Puma::Const::LOCALHOST = T.let(T.unsafe(nil), String)
Puma::Const::LOCALHOST_ADDR = T.let(T.unsafe(nil), String)
Puma::Const::LOCALHOST_IP = T.let(T.unsafe(nil), String)

# Maximum request body size before it is moved out of memory and into a tempfile for reading.
Puma::Const::MAX_BODY = T.let(T.unsafe(nil), Integer)

# How many requests to attempt inline before sending a client back to
# the reactor to be subject to normal ordering. The idea here is that
# we amortize the cost of going back to the reactor for a well behaved
# but very "greedy" client across 10 requests. This prevents a not
# well behaved client from monopolizing the thread forever.
Puma::Const::MAX_FAST_INLINE = T.let(T.unsafe(nil), Integer)

# This is the maximum header that is allowed before a client is booted.  The parser detects
# this, but we'd also like to do this as well.
Puma::Const::MAX_HEADER = T.let(T.unsafe(nil), Integer)

Puma::Const::NEWLINE = T.let(T.unsafe(nil), String)
Puma::Const::PATH_INFO = T.let(T.unsafe(nil), String)

# The default number of seconds for another request within a persistent
# session.
Puma::Const::PERSISTENT_TIMEOUT = T.let(T.unsafe(nil), Integer)

Puma::Const::PORT_443 = T.let(T.unsafe(nil), String)
Puma::Const::PORT_80 = T.let(T.unsafe(nil), String)
Puma::Const::PUMA_CONFIG = T.let(T.unsafe(nil), String)
Puma::Const::PUMA_PEERCERT = T.let(T.unsafe(nil), String)
Puma::Const::PUMA_SERVER_STRING = T.let(T.unsafe(nil), String)
Puma::Const::PUMA_SOCKET = T.let(T.unsafe(nil), String)
Puma::Const::PUMA_TMP_BASE = T.let(T.unsafe(nil), String)
Puma::Const::PUMA_VERSION = T.let(T.unsafe(nil), String)
Puma::Const::QUERY_STRING = T.let(T.unsafe(nil), String)
Puma::Const::RACK_AFTER_REPLY = T.let(T.unsafe(nil), String)
Puma::Const::RACK_INPUT = T.let(T.unsafe(nil), String)
Puma::Const::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)
Puma::Const::REMOTE_ADDR = T.let(T.unsafe(nil), String)
Puma::Const::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Puma::Const::REQUEST_PATH = T.let(T.unsafe(nil), String)

# The original URI requested by the client.
Puma::Const::REQUEST_URI = T.let(T.unsafe(nil), String)

Puma::Const::RESTART_COMMAND = T.let(T.unsafe(nil), String)
Puma::Const::SERVER_NAME = T.let(T.unsafe(nil), String)
Puma::Const::SERVER_PORT = T.let(T.unsafe(nil), String)
Puma::Const::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)
Puma::Const::SERVER_SOFTWARE = T.let(T.unsafe(nil), String)
Puma::Const::STOP_COMMAND = T.let(T.unsafe(nil), String)
Puma::Const::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)
Puma::Const::TRANSFER_ENCODING2 = T.let(T.unsafe(nil), String)
Puma::Const::TRANSFER_ENCODING_CHUNKED = T.let(T.unsafe(nil), String)
Puma::Const::VERSION = T.let(T.unsafe(nil), String)

# Mininum interval to checks worker health
Puma::Const::WORKER_CHECK_INTERVAL = T.let(T.unsafe(nil), Integer)

# How long to wait when getting some write blocking on the socket when
# sending data back
Puma::Const::WRITE_TIMEOUT = T.let(T.unsafe(nil), Integer)

# The default implement of an event sink object used by Server
# for when certain kinds of events occur in the life of the server.
#
# The methods available are the events that the Server fires.
class Puma::Events
  include ::Puma::Const

  # Create an Events object that prints to +stdout+ and +stderr+.
  #
  # @return [Events] a new instance of Events
  def initialize(stdout, stderr); end

  def debug(str); end

  # Write +str+ to +@stderr+
  def error(str); end

  # Fire callbacks for the named hook
  def fire(hook, *args); end

  def fire_on_booted!; end
  def format(str); end

  # Returns the value of attribute formatter.
  def formatter; end

  # Sets the attribute formatter
  #
  # @param value the value to set the attribute formatter to.
  def formatter=(_arg0); end

  # Write +str+ to +@stdout+
  def log(str); end

  def on_booted(&block); end

  # An HTTP parse error has occurred.
  # +server+ is the Server object, +env+ the request, and +error+ a
  # parsing exception.
  def parse_error(server, env, error); end

  # Register a callback for a given hook
  def register(hook, obj = T.unsafe(nil), &blk); end

  # An SSL error has occurred.
  # +server+ is the Server object, +peeraddr+ peer address, +peercert+
  # any peer certificate (if present), and +error+ an exception object.
  def ssl_error(server, peeraddr, peercert, error); end

  # Returns the value of attribute stderr.
  def stderr; end

  # Returns the value of attribute stdout.
  def stdout; end

  # An unknown error has occurred.
  # +server+ is the Server object, +error+ an exception object,
  # +kind+ some additional info, and +env+ the request.
  def unknown_error(server, error, kind = T.unsafe(nil), env = T.unsafe(nil)); end

  def write(str); end

  class << self
    def null; end
    def stdio; end

    # Returns an Events object which writes its status to 2 StringIO
    # objects.
    def strings; end
  end
end

Puma::Events::DEFAULT = T.let(T.unsafe(nil), Puma::Events)

class Puma::Events::DefaultFormatter
  def call(str); end
end

class Puma::Events::PidFormatter
  def call(str); end
end

# Every standard HTTP code mapped to the appropriate message.
# Generated with:
# curl -s https://www.iana.org/assignments/http-status-codes/http-status-codes-1.csv | \
#   ruby -ne 'm = /^(\d{3}),(?!Unassigned|\(Unused\))([^,]+)/.match($_) and \
#             puts "#{m[1]} => \x27#{m[2].strip}\x27,"'
Puma::HTTP_STATUS_CODES = T.let(T.unsafe(nil), Hash)

class Puma::HttpParser
  def initialize; end

  def body; end
  def error?; end
  def execute(_arg0, _arg1, _arg2); end
  def finish; end
  def finished?; end
  def nread; end
  def reset; end
end

class Puma::HttpParserError < ::IOError; end
class Puma::HttpParserError501 < ::IOError; end

class Puma::IOBuffer
  def <<(_arg0); end
  def append(*_arg0); end
  def capacity; end
  def reset; end
  def to_s; end
  def to_str; end
  def used; end
end

# Puma::Launcher is the single entry point for starting a Puma server based on user
# configuration. It is responsible for taking user supplied arguments and resolving them
# with configuration in `config/puma.rb` or `config/puma/<env>.rb`.
#
# It is responsible for either launching a cluster of Puma workers or a single
# puma server.
class Puma::Launcher
  # Returns an instance of Launcher
  #
  # +conf+ A Puma::Configuration object indicating how to run the server.
  #
  # +launcher_args+ A Hash that currently has one required key `:events`,
  # this is expected to hold an object similar to an `Puma::Events.stdio`,
  # this object will be responsible for broadcasting Puma's internal state
  # to a logging destination. An optional key `:argv` can be supplied,
  # this should be an array of strings, these arguments are re-used when
  # restarting the puma server.
  #
  # Examples:
  #
  #   conf = Puma::Configuration.new do |user_config|
  #     user_config.threads 1, 10
  #     user_config.app do |env|
  #       [200, {}, ["hello world"]]
  #     end
  #   end
  #   Puma::Launcher.new(conf, events: Puma::Events.stdio).run
  #
  # @return [Launcher] a new instance of Launcher
  def initialize(conf, launcher_args = T.unsafe(nil)); end

  # Returns the value of attribute binder.
  def binder; end

  def close_binder_listeners; end

  # Returns the value of attribute config.
  def config; end

  # Return which tcp port the launcher is using, if it's using TCP
  def connected_port; end

  # Delete the configured pidfile
  def delete_pidfile; end

  # Returns the value of attribute events.
  def events; end

  # Begin async shutdown of the server
  def halt; end

  # Returns the value of attribute options.
  def options; end

  # Begin a phased restart if supported
  def phased_restart; end

  # Begin async restart of the server
  def restart; end

  def restart_args; end

  # Returns the value of attribute restart_dir.
  def restart_dir; end

  # Run the server. This blocks until the server is stopped
  def run; end

  # Return stats about the server
  def stats; end

  # Begin async shutdown of the server gracefully
  def stop; end

  # Write a state file that can be used by pumactl to control
  # the server
  def write_state; end

  private

  # @return [Boolean]
  def clustered?; end

  def dependencies_and_files_to_require_after_prune; end
  def environment; end
  def extra_runtime_deps_directories; end
  def generate_restart_data; end
  def graceful_stop; end
  def log(str); end
  def log_thread_status; end
  def prune_bundler; end

  # @return [Boolean]
  def prune_bundler?; end

  def puma_wild_location; end
  def reload_worker_directory; end
  def require_paths_for_gem(gem_spec); end
  def require_rubygems_min_version!(min_version, feature); end
  def restart!; end
  def set_process_title; end
  def set_rack_environment; end
  def setup_signals; end
  def spec_for_gem(gem_name); end
  def title; end

  # @raise [UnsupportedOption]
  def unsupported(str); end

  # If configured, write the pid of the current process out
  # to a file.
  def write_pid; end
end

Puma::Launcher::KEYS_NOT_TO_PERSIST_IN_STATE = T.let(T.unsafe(nil), Array)

module Puma::MiniSSL
  class << self
    def check; end
  end
end

class Puma::MiniSSL::Context
  # @return [Context] a new instance of Context
  def initialize; end

  # Returns the value of attribute ca.
  def ca; end

  # @raise [ArgumentError]
  def ca=(ca); end

  # Returns the value of attribute cert.
  def cert; end

  # @raise [ArgumentError]
  def cert=(cert); end

  def check; end

  # non-jruby Context properties
  def key; end

  # @raise [ArgumentError]
  def key=(key); end

  # Returns the value of attribute no_tlsv1.
  def no_tlsv1; end

  # disables TLSv1
  #
  # @raise [ArgumentError]
  def no_tlsv1=(tlsv1); end

  # Returns the value of attribute no_tlsv1_1.
  def no_tlsv1_1; end

  # disables TLSv1 and TLSv1.1.  Overrides `#no_tlsv1=`
  #
  # @raise [ArgumentError]
  def no_tlsv1_1=(tlsv1_1); end

  # Returns the value of attribute ssl_cipher_filter.
  def ssl_cipher_filter; end

  # Sets the attribute ssl_cipher_filter
  #
  # @param value the value to set the attribute ssl_cipher_filter to.
  def ssl_cipher_filter=(_arg0); end

  # Returns the value of attribute verify_mode.
  def verify_mode; end

  # Sets the attribute verify_mode
  #
  # @param value the value to set the attribute verify_mode to.
  def verify_mode=(_arg0); end
end

class Puma::MiniSSL::ContextBuilder
  # @return [ContextBuilder] a new instance of ContextBuilder
  def initialize(params, events); end

  def context; end

  private

  # Returns the value of attribute events.
  def events; end

  # Returns the value of attribute params.
  def params; end
end

class Puma::MiniSSL::Engine
  def extract; end
  def init?; end
  def inject(_arg0); end
  def peercert; end
  def read; end
  def shutdown; end
  def write(_arg0); end

  class << self
    def client; end
    def server(_arg0); end
  end
end

Puma::MiniSSL::OPENSSL_LIBRARY_VERSION = T.let(T.unsafe(nil), String)
Puma::MiniSSL::OPENSSL_NO_SSL3 = T.let(T.unsafe(nil), TrueClass)
Puma::MiniSSL::OPENSSL_VERSION = T.let(T.unsafe(nil), String)
class Puma::MiniSSL::SSLError < ::StandardError; end

class Puma::MiniSSL::Server
  # @return [Server] a new instance of Server
  def initialize(socket, ctx); end

  def accept; end
  def accept_nonblock; end
  def close; end
  def to_io; end
end

class Puma::MiniSSL::Socket
  # @return [Socket] a new instance of Socket
  def initialize(socket, engine); end

  def <<(data); end
  def close; end

  # @return [Boolean]
  def closed?; end

  def engine_read_all; end
  def flush; end
  def peeraddr; end
  def peercert; end
  def read_and_drop(timeout = T.unsafe(nil)); end
  def read_nonblock(size, *_); end
  def readpartial(size); end

  # @return [Boolean]
  def should_drop_bytes?; end

  def syswrite(data); end
  def to_io; end
  def write(data); end

  # This is a temporary fix to deal with websockets code using
  # write_nonblock. The problem with implementing it properly
  # is that it means we'd have to have the ability to rewind
  # an engine because after we write+extract, the socket
  # write_nonblock call might raise an exception and later
  # code would pass the same data in, but the engine would think
  # it had already written the data in. So for the time being
  # (and since write blocking is quite rare), go ahead and actually
  # block in write_nonblock.
  def write_nonblock(data, *_); end
end

Puma::MiniSSL::VERIFY_FAIL_IF_NO_PEER_CERT = T.let(T.unsafe(nil), Integer)
Puma::MiniSSL::VERIFY_NONE = T.let(T.unsafe(nil), Integer)
Puma::MiniSSL::VERIFY_PEER = T.let(T.unsafe(nil), Integer)

# Provides an IO-like object that always appears to contain no data.
# Used as the value for rack.input when the request has no body.
class Puma::NullIO
  def close; end
  def each; end

  # @return [Boolean]
  def eof?; end

  def gets; end
  def puts(*ary); end

  # Mimics IO#read with no data.
  def read(count = T.unsafe(nil), _buffer = T.unsafe(nil)); end

  def rewind; end
  def size; end
  def sync=(v); end
  def write(*ary); end
end

class Puma::Plugin
  # @return [Plugin] a new instance of Plugin
  def initialize(loader); end

  def in_background(&blk); end

  # @return [Boolean]
  def workers_supported?; end

  class << self
    def create(&blk); end
    def extract_name(ary); end
  end
end

# Matches
#  "C:/Ruby22/lib/ruby/gems/2.2.0/gems/puma-3.0.1/lib/puma/plugin/tmp_restart.rb:3:in `<top (required)>'"
#  AS
#  C:/Ruby22/lib/ruby/gems/2.2.0/gems/puma-3.0.1/lib/puma/plugin/tmp_restart.rb
Puma::Plugin::CALLER_FILE = T.let(T.unsafe(nil), Regexp)

class Puma::PluginLoader
  # @return [PluginLoader] a new instance of PluginLoader
  def initialize; end

  # @raise [UnknownPlugin]
  def create(name); end

  def fire_starts(launcher); end
end

class Puma::PluginRegistry
  # @return [PluginRegistry] a new instance of PluginRegistry
  def initialize; end

  def add_background(blk); end

  # @raise [UnknownPlugin]
  def find(name); end

  def fire_background; end
  def register(name, cls); end
end

Puma::Plugins = T.let(T.unsafe(nil), Puma::PluginRegistry)

# Internal Docs, Not a public interface.
#
# The Reactor object is responsible for ensuring that a request has been
# completely received before it starts to be processed. This may be known as read buffering.
# If read buffering is not done, and no other read buffering is performed (such as by an application server
# such as nginx) then the application would be subject to a slow client attack.
#
# Each Puma "worker" process has its own Reactor. For example if you start puma with `$ puma -w 5` then
# it will have 5 workers and each worker will have it's own reactor.
#
# For a graphical representation of how the reactor works see [architecture.md](https://github.com/puma/puma/blob/master/docs/architecture.md#connection-pipeline).
#
# ## Reactor Flow
#
# A connection comes into a `Puma::Server` instance, it is then passed to a `Puma::Reactor` instance,
# which stores it in an array and waits for any of the connections to be ready for reading.
#
# The waiting/wake up is performed with nio4r, which will use the appropriate backend (libev, Java NIO or
# just plain IO#select). The call to `NIO::Selector#select` will "wake up" and
# return the references to any objects that caused it to "wake". The reactor
# then loops through each of these request objects, and sees if they're complete. If they
# have a full header and body then the reactor passes the request to a thread pool.
# Once in a thread pool, a "worker thread" can run the the application's Ruby code against the request.
#
# If the request is not complete, then it stays in the array, and the next time any
# data is written to that socket reference, then the loop is woken up and it is checked for completeness again.
#
# A detailed example is given in the docs for `run_internal` which is where the bulk
# of this logic lives.
class Puma::Reactor
  # Creates an instance of Puma::Reactor
  #
  # The `server` argument is an instance of `Puma::Server`
  # that is used to write a response for "low level errors"
  # when there is an exception inside of the reactor.
  #
  # The `app_pool` is an instance of `Puma::ThreadPool`.
  # Once a request is fully formed (header and body are received)
  # it will be passed to the `app_pool`.
  #
  # @return [Reactor] a new instance of Reactor
  def initialize(server, app_pool); end

  # This method adds a connection to the reactor
  #
  # Typically called by `Puma::Server` the value passed in
  # is usually a `Puma::Client` object that responds like an IO
  # object.
  #
  # The main body of the reactor loop is in `run_internal` and it
  # will sleep on `NIO::Selector#select`. When a new connection is added to the
  # reactor it cannot be added directly to the `sockets` array, because
  # the `NIO::Selector#select` will not be watching for it yet.
  #
  # Instead what needs to happen is that `NIO::Selector#select` needs to be woken up,
  # the contents of `@input` added to the `sockets` array, and then
  # another call to `NIO::Selector#select` needs to happen. Since the `Puma::Client`
  # object can be read immediately, it does not block, but instead returns
  # right away.
  #
  # This behavior is accomplished by writing to `@trigger` which wakes up
  # the `NIO::Selector#select` and then there is logic to detect the value of `*`,
  # pull the contents from `@input` and add them to the sockets array.
  #
  # If the object passed in has a timeout value in `timeout_at` then
  # it is added to a `@timeouts` array. This array is then re-arranged
  # so that the first element to timeout will be at the front of the
  # array. Then a value to sleep for is derived in the call to `calculate_sleep`
  def add(c); end

  # The `calculate_sleep` sets the value that the `NIO::Selector#select` will
  # sleep for in the main reactor loop when no sockets are being written to.
  #
  # The values kept in `@timeouts` are sorted so that the first timeout
  # comes first in the array. When there are no timeouts the default timeout is used.
  #
  # Otherwise a sleep value is set that is the same as the amount of time it
  # would take for the first element to time out.
  #
  # If that value is in the past, then a sleep value of zero is used.
  def calculate_sleep; end

  # Close all watched sockets and clear them from being watched
  def clear!; end

  def run; end
  def run_in_thread; end
  def shutdown; end

  private

  def clear_monitor(mon); end

  # Until a request is added via the `add` method this method will internally
  # loop, waiting on the `sockets` array objects. The only object in this
  # array at first is the `@ready` IO object, which is the read end of a pipe
  # connected to `@trigger` object. When `@trigger` is written to, then the loop
  # will break on `NIO::Selector#select` and return an array.
  #
  # ## When a request is added:
  #
  # When the `add` method is called, an instance of `Puma::Client` is added to the `@input` array.
  # Next the `@ready` pipe is "woken" by writing a string of `"*"` to `@trigger`.
  #
  # When that happens, the internal loop stops blocking at `NIO::Selector#select` and returns a reference
  # to whatever "woke" it up. On the very first loop, the only thing in `sockets` is `@ready`.
  # When `@trigger` is written-to, the loop "wakes" and the `ready`
  # variable returns an array of arrays that looks like `[[#<IO:fd 10>], [], []]` where the
  # first IO object is the `@ready` object. This first array `[#<IO:fd 10>]`
  # is saved as a `reads` variable.
  #
  # The `reads` variable is iterated through. In the case that the object
  # is the same as the `@ready` input pipe, then we know that there was a `trigger` event.
  #
  # If there was a trigger event, then one byte of `@ready` is read into memory. In the case of the first request,
  # the reactor sees that it's a `"*"` value and the reactor adds the contents of `@input` into the `sockets` array.
  # The while then loop continues to iterate again, but now the `sockets` array contains a `Puma::Client` instance in addition
  # to the `@ready` IO object. For example: `[#<IO:fd 10>, #<Puma::Client:0x3fdc1103bee8 @ready=false>]`.
  #
  # Since the `Puma::Client` in this example has data that has not been read yet,
  # the `NIO::Selector#select` is immediately able to "wake" and read from the `Puma::Client`. At this point the
  # `ready` output looks like this: `[[#<Puma::Client:0x3fdc1103bee8 @ready=false>], [], []]`.
  #
  # Each element in the first entry is iterated over. The `Puma::Client` object is not
  # the `@ready` pipe, so the reactor checks to see if it has the full header and body with
  # the `Puma::Client#try_to_finish` method. If the full request has been sent,
  # then the request is passed off to the `@app_pool` thread pool so that a "worker thread"
  # can pick up the request and begin to execute application logic. This is done
  # via `@app_pool << c`. The `Puma::Client` is then removed from the `sockets` array.
  #
  # If the request body is not present then nothing will happen, and the loop will iterate
  # again. When the client sends more data to the socket the `Puma::Client` object will
  # wake up the `NIO::Selector#select` and it can again be checked to see if it's ready to be
  # passed to the thread pool.
  #
  # ## Time Out Case
  #
  # In addition to being woken via a write to one of the sockets the `NIO::Selector#select` will
  # periodically "time out" of the sleep. One of the functions of this is to check for
  # any requests that have "timed out". At the end of the loop it's checked to see if
  # the first element in the `@timeout` array has exceed its allowed time. If so,
  # the client object is removed from the timeout array, a 408 response is written.
  # Then its connection is closed, and the object is removed from the `sockets` array
  # that watches for new data.
  #
  # This behavior loops until all the objects that have timed out have been removed.
  #
  # Once all the timeouts have been processed, the next duration of the `NIO::Selector#select` sleep
  # will be set to be equal to the amount of time it will take for the next timeout to occur.
  # This calculation happens in `calculate_sleep`.
  def run_internal; end
end

Puma::Reactor::DefaultSleepFor = T.let(T.unsafe(nil), Integer)

# Generic class that is used by `Puma::Cluster` and `Puma::Single` to
# serve requests. This class spawns a new instance of `Puma::Server` via
# a call to `start_server`.
class Puma::Runner
  # @return [Runner] a new instance of Runner
  def initialize(cli, events); end

  def app; end
  def before_restart; end

  # @return [Boolean]
  def daemon?; end

  def debug(str); end

  # @return [Boolean]
  def development?; end

  def error(str); end
  def load_and_bind; end
  def log(str); end
  def output_header(mode); end
  def redirect_io; end

  # @return [Boolean]
  def redirected_io?; end

  def ruby_engine; end
  def start_control; end
  def start_server; end

  # @return [Boolean]
  def test?; end
end

# For some HTTP status codes the client only expects headers.
Puma::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

# The HTTP Server itself. Serves out a single Rack app.
#
# This class is used by the `Puma::Single` and `Puma::Cluster` classes
# to generate one or more `Puma::Server` instances capable of handling requests.
# Each Puma process will contain one `Puma::Server` instance.
#
# The `Puma::Server` instance pulls requests from the socket, adds them to a
# `Puma::Reactor` where they get eventually passed to a `Puma::ThreadPool`.
#
# Each `Puma::Server` will have one reactor and one thread pool.
class Puma::Server
  include ::Puma::Const
  extend ::Forwardable

  # Create a server for the rack app +app+.
  #
  # +events+ is an object which will be called when certain error events occur
  # to be handled. See Puma::Events for the list of current methods to implement.
  #
  # Server#run returns a thread that you can join on to wait for the server
  # to do its work.
  #
  # @return [Server] a new instance of Server
  def initialize(app, events = T.unsafe(nil), options = T.unsafe(nil)); end

  def add_ssl_listener(*args, &block); end
  def add_tcp_listener(*args, &block); end
  def add_unix_listener(*args, &block); end

  # Returns the value of attribute app.
  def app; end

  # Sets the attribute app
  #
  # @param value the value to set the attribute app to.
  def app=(_arg0); end

  # Returns the value of attribute auto_trim_time.
  def auto_trim_time; end

  # Sets the attribute auto_trim_time
  #
  # @param value the value to set the attribute auto_trim_time to.
  def auto_trim_time=(_arg0); end

  def backlog; end
  def begin_restart; end

  # Returns the value of attribute binder.
  def binder; end

  # Sets the attribute binder
  #
  # @param value the value to set the attribute binder to.
  def binder=(_arg0); end

  # @return [Boolean]
  def closed_socket?(socket); end

  def connected_port(*args, &block); end

  # 6 == Socket::IPPROTO_TCP
  # 3 == TCP_CORK
  # 1/0 == turn on/off
  def cork_socket(socket); end

  def default_server_port(env); end

  # Returns the value of attribute early_hints.
  def early_hints; end

  # Sets the attribute early_hints
  #
  # @param value the value to set the attribute early_hints to.
  def early_hints=(_arg0); end

  # Returns the value of attribute events.
  def events; end

  # Returns the value of attribute first_data_timeout.
  def first_data_timeout; end

  # Sets the attribute first_data_timeout
  #
  # @param value the value to set the attribute first_data_timeout to.
  def first_data_timeout=(_arg0); end

  # Wait for all outstanding requests to finish.
  def graceful_shutdown; end

  def halt(sync = T.unsafe(nil)); end
  def handle_check; end

  # Takes the request +req+, invokes the Rack application to construct
  # the response and writes it back to +req.io+.
  #
  # The second parameter +lines+ is a IO-like object unique to this thread.
  # This is normally an instance of Puma::IOBuffer.
  #
  # It'll return +false+ when the connection is closed, this doesn't mean
  # that the response wasn't successful.
  #
  # It'll return +:async+ if the connection remains open but will be handled
  # elsewhere, i.e. the connection has been hijacked by the Rack application.
  #
  # Finally, it'll return +true+ on keep-alive connections.
  def handle_request(req, lines); end

  def handle_servers; end
  def handle_servers_lopez_mode; end
  def inherit_binder(bind); end

  # Returns the value of attribute leak_stack_on_error.
  def leak_stack_on_error; end

  # Sets the attribute leak_stack_on_error
  #
  # @param value the value to set the attribute leak_stack_on_error to.
  def leak_stack_on_error=(_arg0); end

  # A fallback rack response if +@app+ raises as exception.
  def lowlevel_error(e, env); end

  # Returns the value of attribute max_threads.
  def max_threads; end

  # Sets the attribute max_threads
  #
  # @param value the value to set the attribute max_threads to.
  def max_threads=(_arg0); end

  # Returns the value of attribute min_threads.
  def min_threads; end

  # Sets the attribute min_threads
  #
  # @param value the value to set the attribute min_threads to.
  def min_threads=(_arg0); end

  # Given a Hash +env+ for the request read from +client+, add
  # and fixup keys to comply with Rack's env guidelines.
  def normalize_env(env, client); end

  # Returns the value of attribute persistent_timeout.
  def persistent_timeout; end

  # Sets the attribute persistent_timeout
  #
  # @param value the value to set the attribute persistent_timeout to.
  def persistent_timeout=(_arg0); end

  # This number represents the number of requests that
  # the server is capable of taking right now.
  #
  # For example if the number is 5 then it means
  # there are 5 threads sitting idle ready to take
  # a request. If one request comes in, then the
  # value would be 4 until it finishes processing.
  def pool_capacity; end

  # Given a connection on +client+, handle the incoming requests.
  #
  # This method support HTTP Keep-Alive so it may, depending on if the client
  # indicates that it supports keep alive, wait for another request before
  # returning.
  def process_client(client, buffer); end

  # Given the request +env+ from +client+ and the partial body +body+
  # plus a potential Content-Length value +cl+, finish reading
  # the body and return it.
  #
  # If the body is larger than MAX_BODY, a Tempfile object is used
  # for the body, otherwise a StringIO is used.
  def read_body(env, client, body, cl); end

  # Returns the value of attribute reaping_time.
  def reaping_time; end

  # Sets the attribute reaping_time
  #
  # @param value the value to set the attribute reaping_time to.
  def reaping_time=(_arg0); end

  # Runs the server.
  #
  # If +background+ is true (the default) then a thread is spun
  # up in the background to handle requests. Otherwise requests
  # are handled synchronously.
  def run(background = T.unsafe(nil)); end

  # Lopez Mode == raw tcp apps
  def run_lopez_mode(background = T.unsafe(nil)); end

  def running; end

  # @return [Boolean]
  def shutting_down?; end

  # Stops the acceptor thread and then causes the worker threads to finish
  # off the request queue before finally exiting.
  def stop(sync = T.unsafe(nil)); end

  def tcp_mode!; end

  # Returns the value of attribute thread.
  def thread; end

  def uncork_socket(socket); end

  private

  def fast_write(io, str); end
  def fetch_status_code(status); end
  def notify_safely(message); end

  # @return [Boolean]
  def possible_header_injection?(header_value); end

  class << self
    def current; end
  end
end

Puma::Server::ThreadLocalKey = T.let(T.unsafe(nil), Symbol)

# This class is instantiated by the `Puma::Launcher` and used
# to boot and serve a Ruby application when no puma "workers" are needed
# i.e. only using "threaded" mode. For example `$ puma -t 1:5`
#
# At the core of this class is running an instance of `Puma::Server` which
# gets created via the `start_server` method from the `Puma::Runner` class
# that this inherits from.
class Puma::Single < ::Puma::Runner
  def halt; end

  # @return [Boolean]
  def jruby_daemon?; end

  def jruby_daemon_start; end
  def restart; end
  def run; end
  def stats; end
  def stop; end
  def stop_blocked; end
end

# Internal Docs for A simple thread pool management object.
#
# Each Puma "worker" has a thread pool to process requests.
#
# First a connection to a client is made in `Puma::Server`. It is wrapped in a
# `Puma::Client` instance and then passed to the `Puma::Reactor` to ensure
# the whole request is buffered into memory. Once the request is ready, it is passed into
# a thread pool via the `Puma::ThreadPool#<<` operator where it is stored in a `@todo` array.
#
# Each thread in the pool has an internal loop where it pulls a request from the `@todo` array
# and proceses it.
class Puma::ThreadPool
  # Maintain a minimum of +min+ and maximum of +max+ threads
  # in the pool.
  #
  # The block passed is the work that will be performed in each
  # thread.
  #
  # @return [ThreadPool] a new instance of ThreadPool
  def initialize(min, max, *extra, &block); end

  # Add +work+ to the todo list for a Thread to pickup and process.
  def <<(work); end

  def auto_reap!(timeout = T.unsafe(nil)); end
  def auto_trim!(timeout = T.unsafe(nil)); end

  # How many objects have yet to be processed by the pool?
  def backlog; end

  # Returns the value of attribute clean_thread_locals.
  def clean_thread_locals; end

  # Sets the attribute clean_thread_locals
  #
  # @param value the value to set the attribute clean_thread_locals to.
  def clean_thread_locals=(_arg0); end

  def pool_capacity; end

  # If there are dead threads in the pool make them go away while decreasing
  # spawned counter so that new healthy threads could be created again.
  def reap; end

  # Tell all threads in the pool to exit and wait for them to finish.
  def shutdown(timeout = T.unsafe(nil)); end

  # Returns the value of attribute spawned.
  def spawned; end

  # If too many threads are in the pool, tell one to finish go ahead
  # and exit. If +force+ is true, then a trim request is requested
  # even if all threads are being utilized.
  def trim(force = T.unsafe(nil)); end

  # Returns the value of attribute trim_requested.
  def trim_requested; end

  # This method is used by `Puma::Server` to let the server know when
  # the thread pool can pull more requests from the socket and
  # pass to the reactor.
  #
  # The general idea is that the thread pool can only work on a fixed
  # number of requests at the same time. If it is already processing that
  # number of requests then it is at capacity. If another Puma process has
  # spare capacity, then the request can be left on the socket so the other
  # worker can pick it up and process it.
  #
  # For example: if there are 5 threads, but only 4 working on
  # requests, this method will not wait and the `Puma::Server`
  # can pull a request right away.
  #
  # If there are 5 threads and all 5 of them are busy, then it will
  # pause here, and wait until the `not_full` condition variable is
  # signaled, usually this indicates that a request has been processed.
  #
  # It's important to note that even though the server might accept another
  # request, it might not be added to the `@todo` array right away.
  # For example if a slow client has only sent a header, but not a body
  # then the `@todo` array would stay the same size as the reactor works
  # to try to buffer the request. In that scenario the next call to this
  # method would not block and another request would be added into the reactor
  # by the server. This would continue until a fully bufferend request
  # makes it through the reactor and can then be processed by the thread pool.
  #
  # Returns the current number of busy threads, or +nil+ if shutting down.
  def wait_until_not_full; end

  # Returns the value of attribute waiting.
  def waiting; end

  private

  #
  # Must be called with @mutex held!
  def spawn_thread; end

  class << self
    def clean_thread_locals; end
  end
end

class Puma::ThreadPool::Automaton
  # @return [Automaton] a new instance of Automaton
  def initialize(pool, timeout, thread_name, message); end

  def start!; end
  def stop; end
end

class Puma::ThreadPool::ForceShutdown < ::RuntimeError; end

# How long, after raising the ForceShutdown of a thread during
# forced shutdown mode, to wait for the thread to try and finish
# up its work before leaving the thread to die on the vine.
Puma::ThreadPool::SHUTDOWN_GRACE_TIME = T.let(T.unsafe(nil), Integer)

class Puma::UnknownPlugin < ::RuntimeError; end
class Puma::UnsupportedOption < ::RuntimeError; end

module Puma::Util
  private

  # Stolen from Mongrel, with some small modifications:
  # Parses a query string by breaking it up at the '&'
  # and ';' characters.  You can also use this to parse
  # cookies by changing the characters used in the second
  # parameter (which defaults to '&;').
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end

  def pipe; end
  def unescape(s, encoding = T.unsafe(nil)); end

  class << self
    # Stolen from Mongrel, with some small modifications:
    # Parses a query string by breaking it up at the '&'
    # and ';' characters.  You can also use this to parse
    # cookies by changing the characters used in the second
    # parameter (which defaults to '&;').
    def parse_query(qs, d = T.unsafe(nil), &unescaper); end

    def pipe; end
    def unescape(s, encoding = T.unsafe(nil)); end
  end
end

Puma::Util::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

# A case-insensitive Hash that preserves the original case of a
# header when set.
class Puma::Util::HeaderHash < ::Hash
  # @return [HeaderHash] a new instance of HeaderHash
  def initialize(hash = T.unsafe(nil)); end

  def [](k); end
  def []=(k, v); end
  def delete(k); end
  def each; end

  # @return [Boolean]
  def has_key?(k); end

  # @return [Boolean]
  def include?(k); end

  # @return [Boolean]
  def key?(k); end

  # @return [Boolean]
  def member?(k); end

  def merge(other); end
  def merge!(other); end
  def replace(other); end
  def to_hash; end

  class << self
    def new(hash = T.unsafe(nil)); end
  end
end
