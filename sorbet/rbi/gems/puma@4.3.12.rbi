# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `puma` gem.
# Please instead update this file by running `bin/tapioca gem puma`.

# source://puma//lib/puma/accept_nonblock.rb#7
class OpenSSL::SSL::SSLServer
  # source://puma//lib/puma/accept_nonblock.rb#9
  def accept_nonblock; end
end

# source://puma//lib/puma.rb#13
module Puma
  class << self
    # source://puma//lib/puma/detect.rb#6
    def jruby?; end

    # source://puma//lib/puma.rb#27
    def set_thread_name(name); end

    # source://puma//lib/puma.rb#22
    def stats; end

    # source://puma//lib/puma.rb#18
    def stats_object=(val); end

    # source://puma//lib/puma/detect.rb#12
    def windows?; end
  end
end

# source://puma//lib/puma/binder.rb#11
class Puma::Binder
  include ::Puma::Const

  # source://puma//lib/puma/binder.rb#16
  def initialize(events); end

  # source://puma//lib/puma/binder.rb#254
  def add_ssl_listener(host, port, ctx, optimize_for_latency = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # source://puma//lib/puma/binder.rb#220
  def add_tcp_listener(host, port, optimize_for_latency = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # source://puma//lib/puma/binder.rb#307
  def add_unix_listener(path, umask = T.unsafe(nil), mode = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # source://puma//lib/puma/binder.rb#52
  def close; end

  # source://puma//lib/puma/binder.rb#362
  def close_listeners; end

  # source://puma//lib/puma/binder.rb#372
  def close_unix_paths; end

  # source://puma//lib/puma/binder.rb#241
  def connected_port; end

  # source://puma//lib/puma/binder.rb#48
  def env(sock); end

  # source://puma//lib/puma/binder.rb#56
  def import_from_env; end

  # source://puma//lib/puma/binder.rb#285
  def inherit_ssl_listener(fd, ctx); end

  # source://puma//lib/puma/binder.rb#243
  def inherit_tcp_listener(host, port, fd); end

  # source://puma//lib/puma/binder.rb#345
  def inherit_unix_listener(path, fd); end

  # source://puma//lib/puma/binder.rb#46
  def ios; end

  # source://puma//lib/puma/binder.rb#207
  def loopback_addresses; end

  # source://puma//lib/puma/binder.rb#89
  def parse(binds, logger); end

  # source://puma//lib/puma/binder.rb#376
  def redirects_for_restart; end
end

# source://puma//lib/puma/binder.rb#14
Puma::Binder::RACK_VERSION = T.let(T.unsafe(nil), Array)

# source://puma//lib/puma/client.rb#41
class Puma::Client
  include ::Puma::Const
  extend ::Forwardable

  # source://puma//lib/puma/client.rb#62
  def initialize(io, env = T.unsafe(nil)); end

  # source://puma//lib/puma/client.rb#95
  def body; end

  # source://puma//lib/puma/client.rb#110
  def call; end

  # source://puma//lib/puma/client.rb#159
  def close; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def closed?(*args, &block); end

  # source://puma//lib/puma/client.rb#252
  def eagerly_finish; end

  # source://puma//lib/puma/client.rb#95
  def env; end

  # source://puma//lib/puma/client.rb#259
  def finish; end

  # source://puma//lib/puma/client.rb#95
  def hijacked; end

  # source://puma//lib/puma/client.rb#115
  def in_data_phase; end

  # source://puma//lib/puma/client.rb#104
  def inspect; end

  # source://puma//lib/puma/client.rb#95
  def io; end

  # source://puma//lib/puma/client.rb#274
  def peerip; end

  # source://puma//lib/puma/client.rb#98
  def peerip=(_arg0); end

  # source://puma//lib/puma/client.rb#95
  def ready; end

  # source://puma//lib/puma/client.rb#100
  def remote_addr_header; end

  # source://puma//lib/puma/client.rb#100
  def remote_addr_header=(_arg0); end

  # source://puma//lib/puma/client.rb#123
  def reset(fast_check = T.unsafe(nil)); end

  # source://puma//lib/puma/client.rb#119
  def set_timeout(val); end

  # source://puma//lib/puma/client.rb#95
  def tempfile; end

  # source://puma//lib/puma/client.rb#95
  def timeout_at; end

  # source://puma//lib/puma/client.rb#95
  def to_io; end

  # source://puma//lib/puma/client.rb#167
  def try_to_finish; end

  # source://puma//lib/puma/client.rb#267
  def write_error(status_code); end

  private

  # source://puma//lib/puma/client.rb#460
  def decode_chunk(chunk); end

  # source://puma//lib/puma/client.rb#369
  def read_body; end

  # source://puma//lib/puma/client.rb#414
  def read_chunked_body; end

  # source://puma//lib/puma/client.rb#549
  def set_ready; end

  # source://puma//lib/puma/client.rb#288
  def setup_body; end

  # source://puma//lib/puma/client.rb#439
  def setup_chunked_body(body); end

  # source://puma//lib/puma/client.rb#456
  def write_chunk(str); end
end

# source://puma//lib/puma/client.rb#44
Puma::Client::ALLOWED_TRANSFER_ENCODING = T.let(T.unsafe(nil), Array)

# source://puma//lib/puma/client.rb#47
Puma::Client::CHUNK_SIZE_INVALID = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/client.rb#48
Puma::Client::CHUNK_VALID_ENDING = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/client.rb#51
Puma::Client::CONTENT_LENGTH_VALUE_INVALID = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/client.rb#57
Puma::Client::EmptyBody = T.let(T.unsafe(nil), Puma::NullIO)

# source://puma//lib/puma/client.rb#53
Puma::Client::TE_ERR_MSG = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/cluster.rb#21
class Puma::Cluster < ::Puma::Runner
  # source://puma//lib/puma/cluster.rb#22
  def initialize(cli, events); end

  # source://puma//lib/puma/cluster.rb#178
  def all_workers_booted?; end

  # source://puma//lib/puma/cluster.rb#182
  def check_workers(force = T.unsafe(nil)); end

  # source://puma//lib/puma/cluster.rb#156
  def cull_workers; end

  # source://puma//lib/puma/cluster.rb#340
  def halt; end

  # source://puma//lib/puma/cluster.rb#171
  def next_worker_index; end

  # source://puma//lib/puma/cluster.rb#319
  def phased_restart; end

  # source://puma//lib/puma/cluster.rb#360
  def preload?; end

  # source://puma//lib/puma/cluster.rb#59
  def redirect_io; end

  # source://puma//lib/puma/cluster.rb#345
  def reload_worker_directory; end

  # source://puma//lib/puma/cluster.rb#314
  def restart; end

  # source://puma//lib/puma/cluster.rb#402
  def run; end

  # source://puma//lib/puma/cluster.rb#366
  def setup_signals; end

  # source://puma//lib/puma/cluster.rb#128
  def spawn_workers; end

  # source://puma//lib/puma/cluster.rb#48
  def start_phased_restart; end

  # source://puma//lib/puma/cluster.rb#353
  def stats; end

  # source://puma//lib/puma/cluster.rb#328
  def stop; end

  # source://puma//lib/puma/cluster.rb#333
  def stop_blocked; end

  # source://puma//lib/puma/cluster.rb#33
  def stop_workers; end

  # source://puma//lib/puma/cluster.rb#227
  def wakeup!; end

  # source://puma//lib/puma/cluster.rb#237
  def worker(index, master); end

  private

  # source://puma//lib/puma/cluster.rb#539
  def wait_workers; end
end

# source://puma//lib/puma/cluster.rb#65
class Puma::Cluster::Worker
  # source://puma//lib/puma/cluster.rb#66
  def initialize(idx, pid, phase, options); end

  # source://puma//lib/puma/cluster.rb#86
  def boot!; end

  # source://puma//lib/puma/cluster.rb#82
  def booted?; end

  # source://puma//lib/puma/cluster.rb#122
  def hup; end

  # source://puma//lib/puma/cluster.rb#80
  def index; end

  # source://puma//lib/puma/cluster.rb#117
  def kill; end

  # source://puma//lib/puma/cluster.rb#80
  def last_checkin; end

  # source://puma//lib/puma/cluster.rb#80
  def last_status; end

  # source://puma//lib/puma/cluster.rb#80
  def phase; end

  # source://puma//lib/puma/cluster.rb#80
  def pid; end

  # source://puma//lib/puma/cluster.rb#95
  def ping!(status); end

  # source://puma//lib/puma/cluster.rb#100
  def ping_timeout?(which); end

  # source://puma//lib/puma/cluster.rb#80
  def signal; end

  # source://puma//lib/puma/cluster.rb#80
  def started_at; end

  # source://puma//lib/puma/cluster.rb#104
  def term; end

  # source://puma//lib/puma/cluster.rb#91
  def term?; end
end

# source://puma//lib/puma/client.rb#24
class Puma::ConnectionError < ::RuntimeError; end

# source://puma//lib/puma/const.rb#101
module Puma::Const; end

# source://puma//lib/puma/const.rb#187
Puma::Const::CGI_VER = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#228
Puma::Const::CHUNKED = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#154
Puma::Const::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#214
Puma::Const::CLOSE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#226
Puma::Const::CLOSE_CHUNKED = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#104
Puma::Const::CODE_NAME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#230
Puma::Const::COLON = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#222
Puma::Const::CONNECTION_CLOSE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#223
Puma::Const::CONNECTION_KEEP_ALIVE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#132
Puma::Const::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#217
Puma::Const::CONTENT_LENGTH2 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#218
Puma::Const::CONTENT_LENGTH_S = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#208
Puma::Const::CONTINUE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#239
Puma::Const::EARLY_HINTS = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#138
Puma::Const::ERROR_RESPONSE = T.let(T.unsafe(nil), Hash)

# source://puma//lib/puma/const.rb#107
Puma::Const::FAST_TRACK_KA_TIMEOUT = T.let(T.unsafe(nil), Float)

# source://puma//lib/puma/const.rb#115
Puma::Const::FIRST_DATA_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#186
Puma::Const::GATEWAY_INTERFACE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#190
Puma::Const::HALT_COMMAND = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#164
Puma::Const::HEAD = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#236
Puma::Const::HIJACK = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#237
Puma::Const::HIJACK_IO = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#235
Puma::Const::HIJACK_P = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#200
Puma::Const::HTTP = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#201
Puma::Const::HTTPS = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#203
Puma::Const::HTTPS_KEY = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#212
Puma::Const::HTTP_10_200 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#183
Puma::Const::HTTP_11 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#210
Puma::Const::HTTP_11_100 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#211
Puma::Const::HTTP_11_200 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#206
Puma::Const::HTTP_CONNECTION = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#207
Puma::Const::HTTP_EXPECT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#175
Puma::Const::HTTP_HOST = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#233
Puma::Const::HTTP_INJECTION_REGEX = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/const.rb#205
Puma::Const::HTTP_VERSION = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#168
Puma::Const::HTTP_X_FORWARDED_FOR = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#171
Puma::Const::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#170
Puma::Const::HTTP_X_FORWARDED_SCHEME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#169
Puma::Const::HTTP_X_FORWARDED_SSL = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#215
Puma::Const::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#166
Puma::Const::LINE_END = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#178
Puma::Const::LOCALHOST = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#180
Puma::Const::LOCALHOST_ADDR = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#179
Puma::Const::LOCALHOST_IP = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#161
Puma::Const::MAX_BODY = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#126
Puma::Const::MAX_FAST_INLINE = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#158
Puma::Const::MAX_HEADER = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#232
Puma::Const::NEWLINE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#134
Puma::Const::PATH_INFO = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#111
Puma::Const::PERSISTENT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#177
Puma::Const::PORT_443 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#176
Puma::Const::PORT_80 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#197
Puma::Const::PUMA_CONFIG = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#198
Puma::Const::PUMA_PEERCERT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#105
Puma::Const::PUMA_SERVER_STRING = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#196
Puma::Const::PUMA_SOCKET = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#136
Puma::Const::PUMA_TMP_BASE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#103
Puma::Const::PUMA_VERSION = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#131
Puma::Const::QUERY_STRING = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#195
Puma::Const::RACK_AFTER_REPLY = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#193
Puma::Const::RACK_INPUT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#194
Puma::Const::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#167
Puma::Const::REMOTE_ADDR = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#163
Puma::Const::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#130
Puma::Const::REQUEST_PATH = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#129
Puma::Const::REQUEST_URI = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#191
Puma::Const::RESTART_COMMAND = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#173
Puma::Const::SERVER_NAME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#174
Puma::Const::SERVER_PORT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#182
Puma::Const::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#185
Puma::Const::SERVER_SOFTWARE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#189
Puma::Const::STOP_COMMAND = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#219
Puma::Const::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#220
Puma::Const::TRANSFER_ENCODING2 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#225
Puma::Const::TRANSFER_ENCODING_CHUNKED = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#103
Puma::Const::VERSION = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#242
Puma::Const::WORKER_CHECK_INTERVAL = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#119
Puma::Const::WRITE_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/events.rb#13
class Puma::Events
  include ::Puma::Const

  # source://puma//lib/puma/events.rb#30
  def initialize(stdout, stderr); end

  # source://puma//lib/puma/events.rb#76
  def debug(str); end

  # source://puma//lib/puma/events.rb#82
  def error(str); end

  # source://puma//lib/puma/events.rb#48
  def fire(hook, *args); end

  # source://puma//lib/puma/events.rb#134
  def fire_on_booted!; end

  # source://puma//lib/puma/events.rb#87
  def format(str); end

  # source://puma//lib/puma/events.rb#44
  def formatter; end

  # source://puma//lib/puma/events.rb#44
  def formatter=(_arg0); end

  # source://puma//lib/puma/events.rb#68
  def log(str); end

  # source://puma//lib/puma/events.rb#130
  def on_booted(&block); end

  # source://puma//lib/puma/events.rb#95
  def parse_error(server, env, error); end

  # source://puma//lib/puma/events.rb#54
  def register(hook, obj = T.unsafe(nil), &blk); end

  # source://puma//lib/puma/events.rb#106
  def ssl_error(server, peeraddr, peercert, error); end

  # source://puma//lib/puma/events.rb#43
  def stderr; end

  # source://puma//lib/puma/events.rb#43
  def stdout; end

  # source://puma//lib/puma/events.rb#115
  def unknown_error(server, error, kind = T.unsafe(nil), env = T.unsafe(nil)); end

  # source://puma//lib/puma/events.rb#72
  def write(str); end

  class << self
    # source://puma//lib/puma/events.rb#151
    def null; end

    # source://puma//lib/puma/events.rb#147
    def stdio; end

    # source://puma//lib/puma/events.rb#143
    def strings; end
  end
end

# source://puma//lib/puma/events.rb#138
Puma::Events::DEFAULT = T.let(T.unsafe(nil), Puma::Events)

# source://puma//lib/puma/events.rb#14
class Puma::Events::DefaultFormatter
  # source://puma//lib/puma/events.rb#15
  def call(str); end
end

# source://puma//lib/puma/events.rb#20
class Puma::Events::PidFormatter
  # source://puma//lib/puma/events.rb#21
  def call(str); end
end

# source://puma//lib/puma/const.rb#18
Puma::HTTP_STATUS_CODES = T.let(T.unsafe(nil), Hash)

class Puma::HttpParser
  def initialize; end

  def body; end
  def error?; end
  def execute(_arg0, _arg1, _arg2); end
  def finish; end
  def finished?; end
  def nread; end
  def reset; end
end

class Puma::HttpParserError < ::IOError; end

# source://puma//lib/puma/client.rb#26
class Puma::HttpParserError501 < ::IOError; end

class Puma::IOBuffer
  def <<(_arg0); end
  def append(*_arg0); end
  def capacity; end
  def reset; end
  def to_s; end
  def to_str; end
  def used; end
end

# source://puma//lib/puma/detect.rb#4
Puma::IS_JRUBY = T.let(T.unsafe(nil), T.untyped)

# source://puma//lib/puma/detect.rb#10
Puma::IS_WINDOWS = T.let(T.unsafe(nil), T.untyped)

# source://puma//lib/puma/launcher.rb#17
class Puma::Launcher
  # source://puma//lib/puma/launcher.rb#43
  def initialize(conf, launcher_args = T.unsafe(nil)); end

  # source://puma//lib/puma/launcher.rb#95
  def binder; end

  # source://puma//lib/puma/launcher.rb#204
  def close_binder_listeners; end

  # source://puma//lib/puma/launcher.rb#95
  def config; end

  # source://puma//lib/puma/launcher.rb#191
  def connected_port; end

  # source://puma//lib/puma/launcher.rb#121
  def delete_pidfile; end

  # source://puma//lib/puma/launcher.rb#95
  def events; end

  # source://puma//lib/puma/launcher.rb#127
  def halt; end

  # source://puma//lib/puma/launcher.rb#95
  def options; end

  # source://puma//lib/puma/launcher.rb#145
  def phased_restart; end

  # source://puma//lib/puma/launcher.rb#139
  def restart; end

  # source://puma//lib/puma/launcher.rb#195
  def restart_args; end

  # source://puma//lib/puma/launcher.rb#95
  def restart_dir; end

  # source://puma//lib/puma/launcher.rb#154
  def run; end

  # source://puma//lib/puma/launcher.rb#98
  def stats; end

  # source://puma//lib/puma/launcher.rb#133
  def stop; end

  # source://puma//lib/puma/launcher.rb#104
  def write_state; end

  private

  # source://puma//lib/puma/launcher.rb#311
  def clustered?; end

  # source://puma//lib/puma/launcher.rb#249
  def dependencies_and_files_to_require_after_prune; end

  # source://puma//lib/puma/launcher.rb#356
  def environment; end

  # source://puma//lib/puma/launcher.rb#259
  def extra_runtime_deps_directories; end

  # source://puma//lib/puma/launcher.rb#364
  def generate_restart_data; end

  # source://puma//lib/puma/launcher.rb#320
  def graceful_stop; end

  # source://puma//lib/puma/launcher.rb#307
  def log(str); end

  # source://puma//lib/puma/launcher.rb#326
  def log_thread_status; end

  # source://puma//lib/puma/launcher.rb#277
  def prune_bundler; end

  # source://puma//lib/puma/launcher.rb#360
  def prune_bundler?; end

  # source://puma//lib/puma/launcher.rb#270
  def puma_wild_location; end

  # source://puma//lib/puma/launcher.rb#223
  def reload_worker_directory; end

  # source://puma//lib/puma/launcher.rb#303
  def require_paths_for_gem(gem_spec); end

  # source://puma//lib/puma/launcher.rb#468
  def require_rubygems_min_version!(min_version, feature); end

  # source://puma//lib/puma/launcher.rb#227
  def restart!; end

  # source://puma//lib/puma/launcher.rb#341
  def set_process_title; end

  # source://puma//lib/puma/launcher.rb#351
  def set_rack_environment; end

  # source://puma//lib/puma/launcher.rb#409
  def setup_signals; end

  # source://puma//lib/puma/launcher.rb#299
  def spec_for_gem(gem_name); end

  # source://puma//lib/puma/launcher.rb#345
  def title; end

  # source://puma//lib/puma/launcher.rb#315
  def unsupported(str); end

  # source://puma//lib/puma/launcher.rb#212
  def write_pid; end
end

# source://puma//lib/puma/launcher.rb#18
Puma::Launcher::KEYS_NOT_TO_PERSIST_IN_STATE = T.let(T.unsafe(nil), Array)

# source://puma//lib/puma/minissl.rb#9
module Puma::MiniSSL
  class << self
    def check; end
  end
end

# source://puma//lib/puma/minissl.rb#177
class Puma::MiniSSL::Context
  # source://puma//lib/puma/minissl.rb#181
  def initialize; end

  # source://puma//lib/puma/minissl.rb#205
  def ca; end

  # source://puma//lib/puma/minissl.rb#218
  def ca=(ca); end

  # source://puma//lib/puma/minissl.rb#204
  def cert; end

  # source://puma//lib/puma/minissl.rb#213
  def cert=(cert); end

  # source://puma//lib/puma/minissl.rb#223
  def check; end

  # source://puma//lib/puma/minissl.rb#203
  def key; end

  # source://puma//lib/puma/minissl.rb#208
  def key=(key); end

  # source://puma//lib/puma/minissl.rb#179
  def no_tlsv1; end

  # source://puma//lib/puma/minissl.rb#230
  def no_tlsv1=(tlsv1); end

  # source://puma//lib/puma/minissl.rb#179
  def no_tlsv1_1; end

  # source://puma//lib/puma/minissl.rb#236
  def no_tlsv1_1=(tlsv1_1); end

  # source://puma//lib/puma/minissl.rb#206
  def ssl_cipher_filter; end

  # source://puma//lib/puma/minissl.rb#206
  def ssl_cipher_filter=(_arg0); end

  # source://puma//lib/puma/minissl.rb#178
  def verify_mode; end

  # source://puma//lib/puma/minissl.rb#178
  def verify_mode=(_arg0); end
end

# source://puma//lib/puma/minissl/context_builder.rb#3
class Puma::MiniSSL::ContextBuilder
  # source://puma//lib/puma/minissl/context_builder.rb#4
  def initialize(params, events); end

  # source://puma//lib/puma/minissl/context_builder.rb#12
  def context; end

  private

  # source://puma//lib/puma/minissl/context_builder.rb#73
  def events; end

  # source://puma//lib/puma/minissl/context_builder.rb#73
  def params; end
end

class Puma::MiniSSL::Engine
  def extract; end
  def init?; end
  def inject(_arg0); end
  def peercert; end
  def read; end
  def shutdown; end
  def write(_arg0); end

  class << self
    def client; end
    def server(_arg0); end
  end
end

Puma::MiniSSL::OPENSSL_LIBRARY_VERSION = T.let(T.unsafe(nil), String)
Puma::MiniSSL::OPENSSL_NO_SSL3 = T.let(T.unsafe(nil), TrueClass)
Puma::MiniSSL::OPENSSL_NO_TLS1 = T.let(T.unsafe(nil), FalseClass)
Puma::MiniSSL::OPENSSL_NO_TLS1_1 = T.let(T.unsafe(nil), FalseClass)
Puma::MiniSSL::OPENSSL_VERSION = T.let(T.unsafe(nil), String)
class Puma::MiniSSL::SSLError < ::StandardError; end

# source://puma//lib/puma/minissl.rb#247
class Puma::MiniSSL::Server
  # source://puma//lib/puma/minissl.rb#248
  def initialize(socket, ctx); end

  # source://puma//lib/puma/minissl.rb#257
  def accept; end

  # source://puma//lib/puma/minissl.rb#265
  def accept_nonblock; end

  # source://puma//lib/puma/minissl.rb#273
  def close; end

  # source://puma//lib/puma/minissl.rb#253
  def to_io; end
end

# source://puma//lib/puma/minissl.rb#10
class Puma::MiniSSL::Socket
  # source://puma//lib/puma/minissl.rb#11
  def initialize(socket, engine); end

  # source://puma//lib/puma/minissl.rb#84
  def <<(data); end

  # source://puma//lib/puma/minissl.rb#139
  def close; end

  # source://puma//lib/puma/minissl.rb#21
  def closed?; end

  # source://puma//lib/puma/minissl.rb#42
  def engine_read_all; end

  # source://puma//lib/puma/minissl.rb#122
  def flush; end

  # source://puma//lib/puma/minissl.rb#155
  def peeraddr; end

  # source://puma//lib/puma/minissl.rb#159
  def peercert; end

  # source://puma//lib/puma/minissl.rb#126
  def read_and_drop(timeout = T.unsafe(nil)); end

  # source://puma//lib/puma/minissl.rb#50
  def read_nonblock(size, *_); end

  # source://puma//lib/puma/minissl.rb#25
  def readpartial(size); end

  # source://puma//lib/puma/minissl.rb#135
  def should_drop_bytes?; end

  # source://puma//lib/puma/minissl.rb#84
  def syswrite(data); end

  # source://puma//lib/puma/minissl.rb#17
  def to_io; end

  # source://puma//lib/puma/minissl.rb#84
  def write(data); end

  # source://puma//lib/puma/minissl.rb#118
  def write_nonblock(data, *_); end
end

# source://puma//lib/puma/minissl.rb#245
Puma::MiniSSL::VERIFY_FAIL_IF_NO_PEER_CERT = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/minissl.rb#243
Puma::MiniSSL::VERIFY_NONE = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/minissl.rb#244
Puma::MiniSSL::VERIFY_PEER = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/null_io.rb#7
class Puma::NullIO
  # source://puma//lib/puma/null_io.rb#24
  def close; end

  # source://puma//lib/puma/null_io.rb#12
  def each; end

  # source://puma//lib/puma/null_io.rb#31
  def eof?; end

  # source://puma//lib/puma/null_io.rb#8
  def gets; end

  # source://puma//lib/puma/null_io.rb#38
  def puts(*ary); end

  # source://puma//lib/puma/null_io.rb#17
  def read(count = T.unsafe(nil), _buffer = T.unsafe(nil)); end

  # source://puma//lib/puma/null_io.rb#21
  def rewind; end

  # source://puma//lib/puma/null_io.rb#27
  def size; end

  # source://puma//lib/puma/null_io.rb#35
  def sync=(v); end

  # source://puma//lib/puma/null_io.rb#41
  def write(*ary); end
end

# source://puma//lib/puma/plugin.rb#76
class Puma::Plugin
  # source://puma//lib/puma/plugin.rb#107
  def initialize(loader); end

  # source://puma//lib/puma/plugin.rb#111
  def in_background(&blk); end

  # source://puma//lib/puma/plugin.rb#115
  def workers_supported?; end

  class << self
    # source://puma//lib/puma/plugin.rb#97
    def create(&blk); end

    # source://puma//lib/puma/plugin.rb#90
    def extract_name(ary); end
  end
end

# source://puma//lib/puma/plugin.rb#81
Puma::Plugin::CALLER_FILE = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/plugin.rb#6
class Puma::PluginLoader
  # source://puma//lib/puma/plugin.rb#7
  def initialize; end

  # source://puma//lib/puma/plugin.rb#11
  def create(name); end

  # source://puma//lib/puma/plugin.rb#21
  def fire_starts(launcher); end
end

# source://puma//lib/puma/plugin.rb#30
class Puma::PluginRegistry
  # source://puma//lib/puma/plugin.rb#31
  def initialize; end

  # source://puma//lib/puma/plugin.rb#60
  def add_background(blk); end

  # source://puma//lib/puma/plugin.rb#40
  def find(name); end

  # source://puma//lib/puma/plugin.rb#64
  def fire_background; end

  # source://puma//lib/puma/plugin.rb#36
  def register(name, cls); end
end

# source://puma//lib/puma/plugin.rb#74
Puma::Plugins = T.let(T.unsafe(nil), Puma::PluginRegistry)

# source://puma//lib/puma/reactor.rb#38
class Puma::Reactor
  # source://puma//lib/puma/reactor.rb#50
  def initialize(server, app_pool); end

  # source://puma//lib/puma/reactor.rb#374
  def add(c); end

  # source://puma//lib/puma/reactor.rb#335
  def calculate_sleep; end

  # source://puma//lib/puma/reactor.rb#382
  def clear!; end

  # source://puma//lib/puma/reactor.rb#302
  def run; end

  # source://puma//lib/puma/reactor.rb#309
  def run_in_thread; end

  # source://puma//lib/puma/reactor.rb#390
  def shutdown; end

  private

  # source://puma//lib/puma/reactor.rb#295
  def clear_monitor(mon); end

  # source://puma//lib/puma/reactor.rb#130
  def run_internal; end
end

# source://puma//lib/puma/reactor.rb#39
Puma::Reactor::DefaultSleepFor = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/runner.rb#11
class Puma::Runner
  # source://puma//lib/puma/runner.rb#12
  def initialize(cli, events); end

  # source://puma//lib/puma/runner.rb#164
  def app; end

  # source://puma//lib/puma/runner.rb#37
  def before_restart; end

  # source://puma//lib/puma/runner.rb#21
  def daemon?; end

  # source://puma//lib/puma/runner.rb#45
  def debug(str); end

  # source://puma//lib/puma/runner.rb#25
  def development?; end

  # source://puma//lib/puma/runner.rb#41
  def error(str); end

  # source://puma//lib/puma/runner.rb#147
  def load_and_bind; end

  # source://puma//lib/puma/runner.rb#33
  def log(str); end

  # source://puma//lib/puma/runner.rb#103
  def output_header(mode); end

  # source://puma//lib/puma/runner.rb#121
  def redirect_io; end

  # source://puma//lib/puma/runner.rb#117
  def redirected_io?; end

  # source://puma//lib/puma/runner.rb#91
  def ruby_engine; end

  # source://puma//lib/puma/runner.rb#49
  def start_control; end

  # source://puma//lib/puma/runner.rb#168
  def start_server; end

  # source://puma//lib/puma/runner.rb#29
  def test?; end
end

# source://puma//lib/puma/const.rb#84
Puma::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

# source://puma//lib/puma/server.rb#32
class Puma::Server
  include ::Puma::Const
  extend ::Forwardable

  # source://puma//lib/puma/server.rb#56
  def initialize(app, events = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def add_ssl_listener(*args, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def add_tcp_listener(*args, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def add_unix_listener(*args, &block); end

  # source://puma//lib/puma/server.rb#39
  def app; end

  # source://puma//lib/puma/server.rb#39
  def app=(_arg0); end

  # source://puma//lib/puma/server.rb#44
  def auto_trim_time; end

  # source://puma//lib/puma/server.rb#44
  def auto_trim_time=(_arg0); end

  # source://puma//lib/puma/server.rb#155
  def backlog; end

  # source://puma//lib/puma/server.rb#1060
  def begin_restart; end

  # source://puma//lib/puma/server.rb#90
  def binder; end

  # source://puma//lib/puma/server.rb#90
  def binder=(_arg0); end

  # source://puma//lib/puma/server.rb#150
  def closed_socket?(socket); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def connected_port(*args, &block); end

  # source://puma//lib/puma/server.rb#144
  def cork_socket(socket); end

  # source://puma//lib/puma/server.rb#621
  def default_server_port(env); end

  # source://puma//lib/puma/server.rb#90
  def early_hints; end

  # source://puma//lib/puma/server.rb#90
  def early_hints=(_arg0); end

  # source://puma//lib/puma/server.rb#38
  def events; end

  # source://puma//lib/puma/server.rb#46
  def first_data_timeout; end

  # source://puma//lib/puma/server.rb#46
  def first_data_timeout=(_arg0); end

  # source://puma//lib/puma/server.rb#979
  def graceful_shutdown; end

  # source://puma//lib/puma/server.rb#1055
  def halt(sync = T.unsafe(nil)); end

  # source://puma//lib/puma/server.rb#443
  def handle_check; end

  # source://puma//lib/puma/server.rb#642
  def handle_request(req, lines); end

  # source://puma//lib/puma/server.rb#368
  def handle_servers; end

  # source://puma//lib/puma/server.rb#217
  def handle_servers_lopez_mode; end

  # source://puma//lib/puma/server.rb#94
  def inherit_binder(bind); end

  # source://puma//lib/puma/server.rb#90
  def leak_stack_on_error; end

  # source://puma//lib/puma/server.rb#90
  def leak_stack_on_error=(_arg0); end

  # source://puma//lib/puma/server.rb#961
  def lowlevel_error(e, env); end

  # source://puma//lib/puma/server.rb#42
  def max_threads; end

  # source://puma//lib/puma/server.rb#42
  def max_threads=(_arg0); end

  # source://puma//lib/puma/server.rb#41
  def min_threads; end

  # source://puma//lib/puma/server.rb#41
  def min_threads=(_arg0); end

  # source://puma//lib/puma/server.rb#568
  def normalize_env(env, client); end

  # source://puma//lib/puma/server.rb#43
  def persistent_timeout; end

  # source://puma//lib/puma/server.rb#43
  def persistent_timeout=(_arg0); end

  # source://puma//lib/puma/server.rb#171
  def pool_capacity; end

  # source://puma//lib/puma/server.rb#467
  def process_client(client, buffer); end

  # source://puma//lib/puma/server.rb#912
  def read_body(env, client, body, cl); end

  # source://puma//lib/puma/server.rb#45
  def reaping_time; end

  # source://puma//lib/puma/server.rb#45
  def reaping_time=(_arg0); end

  # source://puma//lib/puma/server.rb#282
  def run(background = T.unsafe(nil)); end

  # source://puma//lib/puma/server.rb#177
  def run_lopez_mode(background = T.unsafe(nil)); end

  # source://puma//lib/puma/server.rb#159
  def running; end

  # source://puma//lib/puma/server.rb#1091
  def shutting_down?; end

  # source://puma//lib/puma/server.rb#1050
  def stop(sync = T.unsafe(nil)); end

  # source://puma//lib/puma/server.rb#98
  def tcp_mode!; end

  # source://puma//lib/puma/server.rb#37
  def thread; end

  # source://puma//lib/puma/server.rb#147
  def uncork_socket(socket); end

  private

  # source://puma//lib/puma/server.rb#1064
  def fast_write(io, str); end

  # source://puma//lib/puma/server.rb#900
  def fetch_status_code(status); end

  # source://puma//lib/puma/server.rb#1030
  def notify_safely(message); end

  # source://puma//lib/puma/server.rb#1095
  def possible_header_injection?(header_value); end

  class << self
    # source://puma//lib/puma/server.rb#1087
    def current; end
  end
end

# source://puma//lib/puma/server.rb#1085
Puma::Server::ThreadLocalKey = T.let(T.unsafe(nil), Symbol)

# source://puma//lib/puma/single.rb#15
class Puma::Single < ::Puma::Runner
  # source://puma//lib/puma/single.rb#32
  def halt; end

  # source://puma//lib/puma/single.rb#42
  def jruby_daemon?; end

  # source://puma//lib/puma/single.rb#46
  def jruby_daemon_start; end

  # source://puma//lib/puma/single.rb#24
  def restart; end

  # source://puma//lib/puma/single.rb#51
  def run; end

  # source://puma//lib/puma/single.rb#16
  def stats; end

  # source://puma//lib/puma/single.rb#28
  def stop; end

  # source://puma//lib/puma/single.rb#36
  def stop_blocked; end
end

# source://puma//lib/puma/thread_pool.rb#17
class Puma::ThreadPool
  # source://puma//lib/puma/thread_pool.rb#32
  def initialize(min, max, *extra, &block); end

  # source://puma//lib/puma/thread_pool.rb#154
  def <<(work); end

  # source://puma//lib/puma/thread_pool.rb#278
  def auto_reap!(timeout = T.unsafe(nil)); end

  # source://puma//lib/puma/thread_pool.rb#273
  def auto_trim!(timeout = T.unsafe(nil)); end

  # source://puma//lib/puma/thread_pool.rb#74
  def backlog; end

  # source://puma//lib/puma/thread_pool.rb#64
  def clean_thread_locals; end

  # source://puma//lib/puma/thread_pool.rb#64
  def clean_thread_locals=(_arg0); end

  # source://puma//lib/puma/thread_pool.rb#78
  def pool_capacity; end

  # source://puma//lib/puma/thread_pool.rb#231
  def reap; end

  # source://puma//lib/puma/thread_pool.rb#285
  def shutdown(timeout = T.unsafe(nil)); end

  # source://puma//lib/puma/thread_pool.rb#63
  def spawned; end

  # source://puma//lib/puma/thread_pool.rb#220
  def trim(force = T.unsafe(nil)); end

  # source://puma//lib/puma/thread_pool.rb#63
  def trim_requested; end

  # source://puma//lib/puma/thread_pool.rb#199
  def wait_until_not_full; end

  # source://puma//lib/puma/thread_pool.rb#63
  def waiting; end

  private

  # source://puma//lib/puma/thread_pool.rb#86
  def spawn_thread; end

  class << self
    # source://puma//lib/puma/thread_pool.rb#66
    def clean_thread_locals; end
  end
end

# source://puma//lib/puma/thread_pool.rb#246
class Puma::ThreadPool::Automaton
  # source://puma//lib/puma/thread_pool.rb#247
  def initialize(pool, timeout, thread_name, message); end

  # source://puma//lib/puma/thread_pool.rb#255
  def start!; end

  # source://puma//lib/puma/thread_pool.rb#267
  def stop; end
end

# source://puma//lib/puma/thread_pool.rb#18
class Puma::ThreadPool::ForceShutdown < ::RuntimeError; end

# source://puma//lib/puma/thread_pool.rb#24
Puma::ThreadPool::SHUTDOWN_GRACE_TIME = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/plugin.rb#4
class Puma::UnknownPlugin < ::RuntimeError; end

# source://puma//lib/puma/const.rb#5
class Puma::UnsupportedOption < ::RuntimeError; end

# source://puma//lib/puma/util.rb#6
module Puma::Util
  private

  # source://puma//lib/puma/util.rb#33
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end

  # source://puma//lib/puma/util.rb#9
  def pipe; end

  # source://puma//lib/puma/util.rb#16
  def unescape(s, encoding = T.unsafe(nil)); end

  class << self
    # source://puma//lib/puma/util.rb#33
    def parse_query(qs, d = T.unsafe(nil), &unescaper); end

    # source://puma//lib/puma/util.rb#9
    def pipe; end

    # source://puma//lib/puma/util.rb#16
    def unescape(s, encoding = T.unsafe(nil)); end
  end
end

# source://puma//lib/puma/util.rb#26
Puma::Util::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/util.rb#58
class Puma::Util::HeaderHash < ::Hash
  # source://puma//lib/puma/util.rb#63
  def initialize(hash = T.unsafe(nil)); end

  # source://puma//lib/puma/util.rb#81
  def [](k); end

  # source://puma//lib/puma/util.rb#85
  def []=(k, v); end

  # source://puma//lib/puma/util.rb#92
  def delete(k); end

  # source://puma//lib/puma/util.rb#69
  def each; end

  # source://puma//lib/puma/util.rb#99
  def has_key?(k); end

  # source://puma//lib/puma/util.rb#99
  def include?(k); end

  # source://puma//lib/puma/util.rb#99
  def key?(k); end

  # source://puma//lib/puma/util.rb#99
  def member?(k); end

  # source://puma//lib/puma/util.rb#112
  def merge(other); end

  # source://puma//lib/puma/util.rb#107
  def merge!(other); end

  # source://puma//lib/puma/util.rb#117
  def replace(other); end

  # source://puma//lib/puma/util.rb#75
  def to_hash; end

  class << self
    # source://puma//lib/puma/util.rb#59
    def new(hash = T.unsafe(nil)); end
  end
end
